% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Function.R
\name{find_m_logrank}
\alias{find_m_logrank}
\title{\subsection{find_m_logrank}{

This function performs a grid search to find the critical values (m1, m2) for the log-rank test in a two-stage design.
It calculates the probability \code{Prob(W1/sigma1 > m1 & W2/sigma2 > m2 | H_0) = alpha} using the z statistics
(W/sigma) from each simulation. The z statistics can be obtained using the \code{log_rank_sim} function and accessed
via its \code{$z_stats} output.
}}
\usage{
find_m_logrank(
  logrank_data,
  corr_h0,
  search_times,
  int_n = NULL,
  fin_n = NULL,
  alpha,
  sim_size,
  power = NULL
)
}
\arguments{
\item{logrank_data:}{A matrix of log-rank test z statistics for each simulation.}

\item{corr_h0:}{A numeric value representing the correlation of two stages, calculated as \code{sqrt(var(W1) / var(W))}.}

\item{search_times:}{An integer specifying the number of grid search iterations.}

\item{int_n:}{An optional integer specifying the interim sample size (required if \code{power} is given).}

\item{fin_n:}{An optional integer specifying the total sample size in both arms (required if \code{power} is given).}

\item{alpha:}{A numeric value specifying the significance level for hypothesis testing.}

\item{sim_size:}{An integer specifying the number of simulations to perform, say 10000.}

\item{power:}{An optional numeric value specifying the desired power for the test.}
}
\value{
A data frame with the following columns:
\describe{
\item{m1}{Critical value for the first stage test.}
\item{m2}{Critical value for the second stage test.}
\item{PET0}{Probability of early termination under H0.}
\item{PET1}{Probability of early termination under H1.}
\item{alpha}{Overall type I error rate.}
\item{power}{Empirical power of the test.}
\item{PET}{Probability of early termination.}
\item{EN0}{Expected sample size under H0.}
\item{EN1}{Expected sample size under H1.}
\item{EN}{Overall expected sample size.}
}
If no valid critical values are found, the function returns a data frame with \code{m1 = 0, m2 = 0, PET0 = 0, PET1 = 0, alpha = 0, power = 0, PET = 0, EN0 = NA, EN1 = NA, EN = NA}.
}
\description{
When \code{power} is not given, the function finds the critical values (m1, m2) that control the overall type I error
while maximizing the power. When \code{power} is given, it searches for valid critical values such that the empirical
power is greater than the specified \code{power}. If \code{power} is given, \code{int_n} and \code{fin_n} are required
for the expected sample size (E(N)) calculation.
}
\examples{
data_C <- expo_gen_2stages(N = n * sim_size, acc_time = acc_time, lambda = lambda_H0, dist = 'exp', 
                           cen_time = cen_time,arm = 0, interim = interim)    
data_E_H0 <- expo_gen_2stages(N = n * sim_size, acc_time = acc_time, lambda = lambda_H0, dist = 'exp', 
                                cen_time = cen_time,arm = 1, interim = interim)
data_E_H1 <- expo_gen_2stages(N = n * sim_size, acc_time = acc_time, lambda = lambda_H1, dist = 'exp', 
                                cen_time = cen_time,arm = 1, interim = interim)
lr_h0_int <- log_rank_sim(data_C = data_C[ , c(2,3,1)], data_E = data_E_H0[ , c(2,3,1)], 
                        sim_size =  sim_size, n = n, alpha = alpha, sided = 'greater')
lr_h1_int <- log_rank_sim(data_C = data_C[ , c(2,3,1)], data_E = data_E_H1[ , c(2,3,1)], 
                        sim_size =  sim_size, n = n, alpha = alpha, sided = 'greater')
lr_h0_fin <- log_rank_sim(data_C = data_C[ , c(4,5,1)], data_E = data_E_H0[ , c(4,5,1)], 
                        sim_size =  sim_size, n = n, alpha = alpha, sided = 'greater')
lr_h1_fin <- log_rank_sim(data_C = data_C[ , c(4,5,1)], data_E = data_E_H1[ , c(4,5,1)], 
                        sim_size =  sim_size, n = n, alpha = alpha, sided = 'greater')
# Get W/sigma
z_stats_h1_int <- lr_h1_int$z_stats
z_stats_h1_fin <- lr_h1_fin$z_stats
z_stats_h0_int <- lr_h0_int$z_stats
z_stats_h0_fin <- lr_h0_fin$z_stats
logrank_data <- rbind(z_stats_h0_int, z_stats_h1_int, z_stats_h0_fin, z_stats_h1_fin) 
corr_h0 <- sqrt(mean(lr_h0_int$var_w) / mean(lr_h0_fin$var_w)) 

best_lr <- find_m_logrank(logrank_data = logrank_data, search_times = 200, corr_h0 = corr_h0,
                alpha = 0.05, sim_size = 10000)

}
